const _ZERO=BigInt(0),_ONE=BigInt(1),_TWO=BigInt(2);function abs(b){return b=BigInt(b),b>=_ZERO?b:-b}function bitLength(b){if(b=BigInt(b),b===_ONE)return 1;let c=1;do c++;while((b>>=_ONE)>_ONE);return c}function eGcd(c,d){if(c=BigInt(c),d=BigInt(d),c<=_ZERO|d<=_ZERO)return NaN;let e=_ZERO,f=_ONE,g=_ONE,h=_ZERO;for(;c!==_ZERO;){let a=d/c,b=d%c,i=e-g*a,j=f-h*a;d=c,c=b,e=g,f=h,g=i,h=j}return{b:d,x:e,y:f}}function gcd(c,d){if(c=abs(c),d=abs(d),c===_ZERO)return d;if(d===_ZERO)return c;let e=_ZERO;for(;!((c|d)&_ONE);)c>>=_ONE,d>>=_ONE,e++;for(;!(c&_ONE);)c>>=_ONE;do{for(;!(d&_ONE);)d>>=_ONE;if(c>d){let a=c;c=d,d=a}d-=c}while(d);return c<<e}async function isProbablyPrime(a,b=16){return"number"==typeof a&&(a=BigInt(a)),new Promise((c,d)=>{let e=new Worker(_isProbablyPrimeWorkerUrl());e.onmessage=a=>{e.terminate(),c(a.data.isPrime)},e.onmessageerror=a=>{d(a)},e.postMessage({rnd:a,iterations:b,id:0})})}function lcm(c,d){return c=BigInt(c),d=BigInt(d),c===_ZERO&&d===_ZERO?_ZERO:abs(c*d)/gcd(c,d)}function modInv(b,a){if(b==_ZERO|a<=_ZERO)return NaN;let c=eGcd(toZn(b,a),a);return c.b===_ONE?toZn(c.x,a):NaN}function modPow(c,d,e){if(e=BigInt(e),e===_ZERO)return NaN;if(c=toZn(c,e),d=BigInt(d),d<_ZERO)return modInv(modPow(c,abs(d),e),e);let f=_ONE,g=c;for(;0<d;){var h=d%_TWO;d/=_TWO,h==_ONE&&(f*=g,f%=e),g*=g,g%=e}return f}function prime(a,b=16){if(1>a)throw new RangeError(`bitLength MUST be > 0 and it is ${a}`);return new Promise(c=>{let d=[];const e=(e,f)=>{if(e.isPrime){for(let a=0;a<d.length;a++)d[a].terminate();for(;d.length;)d.pop();c(e.value)}else{let c=randBits(a,!0),d=fromBuffer(c);try{f.postMessage({rnd:d,iterations:b,id:e.id})}catch(a){}}};{let a=_isProbablyPrimeWorkerUrl();for(let b,c=0;c<self.navigator.hardwareConcurrency;c++)b=new Worker(a),b.onmessage=a=>e(a.data,b),d.push(b)}for(let e=0;e<d.length;e++){let c=randBits(a,!0),f=fromBuffer(c);d[e].postMessage({rnd:f,iterations:b,id:e})}})}function randBetween(a,b=_ONE){if(a<=b)throw new Error("max must be > min");const c=a-b;let d,e=bitLength(c);do{let a=randBits(e);d=fromBuffer(a)}while(d>c);return d+b}function randBits(a,b=!1){var c=Math.ceil;if(1>a)throw new RangeError(`bitLength MUST be > 0 and it is ${a}`);const d=c(a/8);let e=randBytesSync(d,!1);if(e[0]&=2**(a%8)-1,b){let b=a%8?2**(a%8-1):128;e[0]|=b}return e}function randBytesSync(a,b=!1){if(1>a)throw new RangeError(`byteLength MUST be > 0 and it is ${a}`);let c;return c=new Uint8Array(a),self.crypto.getRandomValues(c),b&&(c[0]|=128),c}function toZn(b,c){return(c=BigInt(c),0>=c)?NaN:(b=BigInt(b)%c,0>b?b+c:b)}function fromBuffer(a){let b=_ZERO;for(let c of a.values()){let a=BigInt(c);b=(b<<BigInt(8))+a}return b}function _isProbablyPrimeWorkerUrl(){let a=`'use strict';const _ZERO = BigInt(0);const _ONE = BigInt(1);const _TWO = BigInt(2);const eGcd = ${eGcd.toString()};const modInv = ${modInv.toString()};const modPow = ${modPow.toString()};const toZn = ${toZn.toString()};const randBits = ${randBits.toString()};const randBytesSync = ${randBytesSync.toString()};const randBetween = ${randBetween.toString()};const isProbablyPrime = ${_isProbablyPrime.toString()};${bitLength.toString()}${fromBuffer.toString()}`;return a+=`onmessage = ${async function(a){const b=await isProbablyPrime(a.data.rnd,a.data.iterations);postMessage({isPrime:b,value:a.data.rnd,id:a.data.id})}.toString()};`,_workerUrl(a)}function _workerUrl(a){a=`(() => {${a}})()`;var b=new Blob([a],{type:"text/javascript"});return window.URL.createObjectURL(b)}function _isProbablyPrime(c,b=16){if(c===_TWO)return!0;if((c&_ONE)===_ZERO||c===_ONE)return!1;const e=[3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597];for(let a=0;a<e.length&&BigInt(e[a])<=c;a++){const b=BigInt(e[a]);if(c===b)return!0;if(c%b===_ZERO)return!1}let f=_ZERO,g=c-_ONE;for(;g%_TWO===_ZERO;)g/=_TWO,++f;let h=(c-_ONE)/_TWO**f;loop:do{let a=randBetween(c-_ONE,_TWO),b=modPow(a,h,c);if(b===_ONE||b===c-_ONE)continue;for(let a=1;a<f;a++){if(b=modPow(b,_TWO,c),b===c-_ONE)continue loop;if(b===_ONE)break}return!1}while(--b);return!0}const _ONE$1=BigInt(1),generateRandomKeys=async function(a=4096,b=!1){var c=Math.floor;let d,e,f,h,i,j,k,l;do d=await prime(c(a/2)+1),e=await prime(c(a/2)),f=d*e;while(e===d||bitLength(f)!=a);h=(d-_ONE$1)*(e-_ONE$1),i=f**BigInt(2),!0===b?(j=f+_ONE$1,k=h,l=modInv(k,f)):(j=getGenerator(f,i),k=lcm(d-_ONE$1,e-_ONE$1),l=modInv(L(modPow(j,k,i),f),f));const m=new PublicKey(f,j),o=new PrivateKey(k,l,d,e,m);return{publicKey:m,privateKey:o}},PublicKey=class{constructor(a,b){this.n=BigInt(a),this._n2=this.n**BigInt(2),this.g=BigInt(b)}get bitLength(){return bitLength(this.n)}encrypt(a){let b;return b=randBetween(this.n),modPow(this.g,a,this._n2)*modPow(b,this.n,this._n2)%this._n2}addition(...a){return a.reduce((a,b)=>a*BigInt(b)%this._n2,_ONE$1)}multiply(a,b){return"string"==typeof b&&(b=BigInt(b)),modPow(BigInt(a),b,this._n2)}},PrivateKey=class{constructor(a,b,c,d,e){this.lambda=BigInt(a),this.mu=BigInt(b),this._p=BigInt(c),this._q=BigInt(d),this.publicKey=e}get bitLength(){return bitLength(this.publicKey.n)}get n(){return this.publicKey.n}decrypt(a){return L(modPow(BigInt(a),this.lambda,this.publicKey._n2),this.publicKey.n)*this.mu%this.publicKey.n}};function L(b,a){return(b-_ONE$1)/a}function getGenerator(a,b=modPow(a,2)){const c=randBetween(a),d=randBetween(a);return(c*a+_ONE$1)*modPow(d,a,b)%b}export{PrivateKey,PublicKey,generateRandomKeys};
